# eXtensible Event Stream (XES)
> IEEE stadard approved September 22 2016 and sponsored by the Standards Committee of the IEEE Computational Intelligence Society.

## History of XES
Unlike tradtional business intelligence tools, process mining takes a deeper look *into* the process and allows for insights on a much finer level. The omnipresence of event logs is a crutial enaler of process mining. Many information system either provide a wholistic log or have the information spread throughout, thus making it possible to extract. The MXML format proven its use as the standard log format in process mining, but has serious shortcomings that have been discovered through extensive use. One of the primary problems being the semantics of additional attributes in the event log. In MXML these are simply treated as string values with a key, and therefore have no understood meaning. Nomenclature has also been proven to be difficult, which is due to the fact that MXML was built on the assumption that it would document strictly structured processes. Strict processes is not always the case. XES was created to address and solve these issues.

XES is a XML based standard for describing event logs and event streams. These logs are commonly exhanged between different information systems and other types of clients, and therefore need to adhere to a fixed and agreed upon standard. XES is this standard. It allows for use of external ontologies, thus having the capability of providing accurate semantics to its content. It is the IEEE standard for describing event logs and event streams. 

XES is designed to resolve some of the discovered issues with MXML, such as concept ambiguity in advanced scenarios. MXML has a series of predefined attributes which have well defined semantics, but lacks a mechanism for describing advanced concepts. It is whenever one tries to expand on any of these well defined attributes or introduce new ones that problems may arise. These concepts do not have to be only domain specific, it could just as well be generic concepts with ambiguity. The semantic meaning of these non-standard attributes are difficult to define in MXML. XES inherits many of the same attributes from MXML, but implement them  differently. XES is built on SA-MXML which is the semantic extension of MXML. XES therefore has a well defined mechanism for describing these complex concepts as one can link to ontologies. Understanding the differences of these formats is not paramount as we are only interested XES. [XES, XESame, and ProM 6](./resources/literature/Verbeek2011_Chapter_XESXESameAndProM6.pdf)

### Comment: is XML becoming obsolete?
JSON is the defacto standard for modern web technologies. How does XML stack up? 

----

>Notes and quoted from @book{IEEEComputationalIntelligenceSociety2016,

*A XES instance corresponds to a file-based event log or a formatted event stream that can be used to transfer event-driven data in a unified and extensible manner from a first site to a second site. *   
*To transfer event-driven data in a unified manner, this standard includes a W3C XML Schema describing the structure of a XES instance.*  
* also includes a W3CXML Schema describing the structure of an extension to such a XES instance.*

*The purpose of this standard is to provide a generally acknowledged XML format for the interchange of event data between information systems in many applications domains on the one hand and analysis tools for such data on the other hand. 
As such, this standard aims to fix the syntax and the semantics of the event data which,for example, is being transferred from the site generating this data to the site analyzing this data.
As a result of this standard, if the event data is transferred using the syntax as described by this standard, its semantics will be well understood and clear at both sites.*

### components
XES i built on a series of components.  
The formal definition as used in this paper for a component is:  
* **component:** An extensible event stream (XES) element that may contain XES attributes, that is, a log, a trace, an event, or an attribute.*

#### Log component
*Represents information that is related to a specific process.*  
The log shall contain a collection of traces followed by a list of events both of which could be empty, but must be present. 
The ordering of the events in the list is important as this represents the order in which they were observed.  

If the log only contains events and no traces, then the log is called a **stream**. I.e if the log is simply one trace.

#### Trace component
Represents the execution of a single case.  Should contain a list of events that relates to that particular case. This list can be empty, but must be present.  Orderin, as mentoned, is important.

#### Event component
The most atomic component.  
If the event occurs in some trace then it is clear to which case it belongs.  If the event does not occur in some trace, i.e in the log, then we need some way of relating events to cases. For this we use **trace classifiers** and **event classifiers**.
> Events do not have to be directly tied to some case, i.e not wrapped in the trace element.  

#### Attribute component
Information pertaining to any component is stored in the attibute component. The aforementioned components are simply wrappers.  
Attributes describe the enclosing component, which can contain any number of attributes.  
> Attributes can nest/wrap attributes
However, no two attributes of the same component can share the same key. 
**Every key shall occur only once in a single component**

Attribute wrapping is not mandatory for complicance. Some tools do not implement this. However, these tool should still be able to read these attributes and then discard them. The user shold then be notified of this.
An attribute has to be either **elementary** or **composite**

#### Elementary attributes
An attribute that contains a value that is singular and basic. These attribute are *string, date and time, integer number, real number, Boolean, ID*.
1. String attribute
- valid values must conform to the xs:string datatype
2. Date and time attribute
- valid values must be specified in UTC (ISO 8601) and represented as xs:dateTime datatype
3. Integer number attribute
- valid values must conform to the xs:long datatype
4. Real number attribute
- valid values must conform to the xs:double datatype
5. Boolean attribute
- valid values must conform to the xs:boolean datatype
6. ID attribute
- valid values must conform to the ID datatype, i.e string representations of UUID.
  
#### Composite attributes
Attribute that may contain multiple values. In the XES standard this is known as a **list attribute**
> Attribute that contains other attributes

Valid values for the list datatype are all series of attribute values. The ordering of child attributes is important. Attributes may share the same key. Should be noted that the attribute value list is not the same as the list attribute.
The list *attribute* can contain value lists. It is also a component. The list *datatype* is not a component. 

### Global attributes
The log should hold a list of global attribute declarations, which can be empty. This attribute shall have key, datatype, and value. This attribute is either a event attribute or trace atrtibute.

#### Global event and trace attribute
Attributes that are understood to be available and properly defined for each event and/or trace in the log. This means that **every** event and/or trace has the attributes declared in this attribute. This includes key,datatype, and value. The events and/or trace themselves can orverride the value. In the event where the event and/or trace has a missing attribute, then this is substituted by the value in the global attribute. It should only be used in this scenario. Global trace attributes pertain to the non-global trace attributes. Global trace attributes can not be used for non-global event attributes.

### Classifiers
In the XES standard there are no predefied attributes with any well-understood meaning. instead a log has to hold a list of classifiers, which can be empty. These classifiers are a mandatory feature. 
A classifier assigns an identity to each event. This makes the event comparable to other events by use of this assigned id. Examples of identities include the descriptive name of the event, and/or its case. A classifier can be either a **event classifier** or **trace classifier**. 

#### Event and Trace classifier
Has to be defined via an ordered list of attribute keys. The identity of the event/trace shall be described from the actual values of the attributes with these keys. An Attribute whose key appears in the event/trace classifier list has to be declared as a global event attribute before the classifier is defined. 

#### Extensions
An extension defines a possibly empty set of attributes for every type of component.   
Extensions provide points of reference for interpreting these attributes, and, thus their components.  
*Extensions, therefore, are primarily a vehicle for attaching semantics to a set of defined attributes per component.*  
Extensions can be used as a set of commonly understood attributes that are vital for a specific perspective or dimension of evnet log analysis. 
Another use is the definition of generally-understood attributes for a specific application domain. (e.g medial attributes for use in the medical domain.)  
An extension has to have a descriptive name, prefix, and unifirm resource identifier (URI). The prefix being the prefix for all attributes defined by the extension. 
They keys of all attributes defined in by the extension have to be prepended with this prefix and a colon separation character. The URI is unique and points to the definition of the extension.

The definition has to contain a list of attribute declarations for every comonent, this list can be empty. 
An attribute declaration has to contain the key of the attribute, the datatype, and a possibly empty list of aliases. 
The alias has to contain the descriptive text for the attribute and the language code of the language of this descriptive text.

![](./../../resources/figuredAndAssorted/XES_IEEE_STATE_FLOW.png)
> Figure of state flow diagram, taken from IEEEComputationalIntelligenceSociety2016



## XML Schema Definition(XSD) describing the current XES standard
> XSD sourced from http://www.xes-standard.org/downloads/xes-ieee-1849-2016-April-15-2020.xsd  
> Additional information about the XES standard is available on their website as well as IEEE  
> XES: https://xes-standard.org/  
> IEEE: https://ieeexplore.ieee.org/document/7740858  

The XML and XSD language is associated with and goverened by the *world wide web consortium*(w3c). XSD was designed *to offer facilities for decribing the structure and constraining the contents of XML documents. 
The schema is used to describe the structure of an XML document. The primary purpose being to strictly define the legal *building blocks* of a XML document.  
These building block are the elements and attributes, number and order of child elements, datatypes, and fixed values.

``` XML
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
	<xs:element name="log" type="LogType"/>
	<!-- Attributables -->
	<xs:group name="AttributableGroup">
		<xs:sequence>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="string" type="AttributeStringType"/>
				<xs:element name="date" type="AttributeDateType"/>
				<xs:element name="int" type="AttributeIntType"/>
				<xs:element name="float" type="AttributeFloatType"/>
				<xs:element name="boolean" type="AttributeBooleanType"/>
				<xs:element name="id" type="AttributeIDType"/>
				<xs:element name="list" type="AttributeListType"/>
			</xs:choice>
		</xs:sequence>
	</xs:group>
	<xs:complexType name="AttributableType">
		<xs:group ref="AttributableGroup"/>
	</xs:complexType>
	<!-- String attribute -->
	<xs:complexType name="AttributeStringType">
		<xs:complexContent>
			<xs:extension base="AttributeType">
				<xs:attribute name="value" type="xs:string" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Date attribute -->
	<xs:complexType name="AttributeDateType">
		<xs:complexContent>
			<xs:extension base="AttributeType">
				<xs:attribute name="value" type="xs:dateTime" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Integer attribute -->
	<xs:complexType name="AttributeIntType">
		<xs:complexContent>
			<xs:extension base="AttributeType">
				<xs:attribute name="value" type="xs:long" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Floating-point attribute -->
	<xs:complexType name="AttributeFloatType">
		<xs:complexContent>
			<xs:extension base="AttributeType">
				<xs:attribute name="value" type="xs:double" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Boolean attribute -->
	<xs:complexType name="AttributeBooleanType">
		<xs:complexContent>
			<xs:extension base="AttributeType">
				<xs:attribute name="value" type="xs:boolean" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- ID attribute -->
	<xs:complexType name="AttributeIDType">
		<xs:complexContent>
			<xs:extension base="AttributeType">
				<xs:attribute name="value" type="xs:string" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- List attribute -->
	<xs:complexType name="AttributeListType">
		<xs:complexContent>
			<xs:extension base="AttributeType">
				<xs:sequence>
					<xs:element name="values" type="AttributeType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Extension definition -->
	<xs:complexType name="ExtensionType">
		<xs:attribute name="name" type="xs:NCName" use="required"/>
		<xs:attribute name="prefix" type="xs:NCName" use="required"/>
		<xs:attribute name="uri" type="xs:anyURI" use="required"/>
	</xs:complexType>
	<!-- Globals definition -->
	<xs:complexType name="GlobalsType">
		<xs:group ref="AttributableGroup"/>
		<xs:attribute name="scope" type="xs:NCName"/>
	</xs:complexType>
	<!-- Classifier definition -->
	<xs:complexType name="ClassifierType">
		<xs:attribute name="name" type="xs:NCName" use="required"/>
		<xs:attribute name="scope" type="xs:NCName"/>
		<xs:attribute name="keys" type="xs:token" use="required"/>
	</xs:complexType>
	<!-- Attribute -->
	<xs:complexType name="AttributeType">
		<xs:complexContent>
			<xs:extension base="AttributableType">
				<xs:attribute name="key" type="xs:Name" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Logs are elements that may contain traces -->
	<xs:complexType name="LogType">
		<xs:sequence>
			<xs:element name="extension" type="ExtensionType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="global" type="GlobalsType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="classifier" type="ClassifierType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:group ref="AttributableGroup"/>
			<xs:element name="trace" type="TraceType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="event" type="EventType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="xes.version" type="xs:decimal" use="required"/>
		<xs:attribute name="xes.features" type="xs:token"/>
	</xs:complexType>
	<!-- Traces are elements that may contain events -->
	<xs:complexType name="TraceType">
		<xs:sequence>
			<xs:group ref="AttributableGroup"/>
			<xs:element name="event" type="EventType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!-- Events are elements -->
	<xs:complexType name="EventType">
		<xs:group ref="AttributableGroup"/>
	</xs:complexType>
</xs:schema>

```
## Working with the XES definition
Provided that the standard has a official XML schema definition we can use freely available tools for checking the conformity of our event logs. While such tools can be used to ensure that the log is syntactically correct, it is up to the author to ensure that the log has the correct semantic meaning. The official document describing the standard is a good reference for investigating these semantics.

As mentioned there are many freely available tools that are useful when working with or creating new XML documents. While there are many standalone tools, i have choosen to use a freely available extension for the popular Visual Studio code IDE created by Microsoft. The extension is created by [red hat](https://www.redhat.com/en) and is freely available on [github](https://github.com/redhat-developer/vscode-xml/blob/master/docs/README.md) and naturally also in the [VScode marketplace](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-xml). 


 ### Creating a XES skeleton file
Skeleton files that contain the absolute minimum while still conforming to the schema. 
Given that the schema defines the grammar for the XML file this naturally implies that it itslef can be used to generate a working example. There are numerouse freely available generators, i chose to use a generator that is available [here](https://www.liquid-technologies.com/online-xsd-to-xml-converter). This then produced the follwing XML document:
```XML
<?xml version="1.0" encoding="utf-8"?>
<!-- Created with Liquid Technologies Online Tools 1.0 (https://www.liquid-technologies.com) -->
<log xsi:noNamespaceSchemaLocation="schema.xsd" xes.version="-4827329.7650942" xes.features="string" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <extension name="string" prefix="string" uri="https://www.liquid-technologies.com" />
  <extension name="string" prefix="string" uri="https://www.liquid-technologies.com" />
  <extension name="string" prefix="string" uri="https://www.liquid-technologies.com" />
  <extension name="string" prefix="string" uri="https://www.liquid-technologies.com" />
  <global />
  <global>
    <date value="2013-05-27T23:28:52.84" key="string" />
    <string value="string" key="string" />
    <string value="string" key="string" />
    <list key="string">
      <values key="string" />
    </list>
  </global>
  <global scope="string">
    <boolean value="true" key="string" />
    <boolean value="0" key="string" />
    <string value="string" key="string" />
    <string value="string" key="string" />
  </global>
  <global scope="string">
    <int value="652" key="string" />
    <int value="-3442" key="string" />
  </global>
  <classifier name="string" scope="string" keys="string" />
  <classifier name="string" keys="string" />
  <id value="string" key="string" />
  <int value="-573" key="string" />
  <string value="string" key="string" />
  <boolean value="false" key="string" />
  <trace>
    <event />
    <event />
  </trace>
  <trace />
  <event>
    <string value="string" key="string" />
    <boolean value="false" key="string" />
    <int value="-445" key="string" />
    <int value="851" key="string" />
  </event>
  <event>
    <string value="string" key="string" />
  </event>
</log>
```
 


